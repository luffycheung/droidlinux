/*
 *  Logical Link Control and Adaptation Protocol (L2CAP) communication for
 *  Human Interface Devices (HID)
 */
/*
 *  Copyright (C) 2012
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#include <ctype.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <bluetooth/bluetooth.h>
#include <bluetooth/l2cap.h>
#include <bluetooth/hidp.h>

#include "error.h"
#include "log.h"
#include "hidipc.h"
#include "hiddescriptor.h"
#include "bluectrld.h"
#include "hidl2cap.h"


/*
 * The default Bluetooth HID Profile MTU is 48. Analysed devices mostly used
 * a value of 185.
 * Bluetooth documentation quote:
 * Ideally, an MTU is negotiated that is at least one byte larger than the
 * largest Report generated by the device. This approach will save the
 * overhead of sending Large payloads.
 */
static const int INPUT_MTU = HIDP_DEFAULT_MTU;
static const int OUTPUT_MTU = HIDP_DEFAULT_MTU;

/*
 * Bluetooth documentation quote:
 * It is recommended that the L2CAP Flush timeout parameter be set to
 * 0xFFFF (infinite) until problems with this function in the L2CAP protocol
 * are addressed in a future revision of the Bluetooth core specification.
 */
static const int FLUSH_TIMEOUT = 0xffff;


/*
 * Server/client control/interrupt sockets.
 */
static int server_ctrl_sock = -1;
static int server_intr_sock = -1;
static int client_ctrl_sock = -1;
static int client_intr_sock = -1;

/*
 * The last or now connected HID host Bluetooth address.
 */
static bdaddr_t last_bdaddr;

/*
 * True if the Report protocol is used; False if the boot protocol is used.
 */
static int use_report_protocol = 1;

/*
 * Data container for the Input and Output Reports.
 */
static unsigned char input_report_keys[10];
static unsigned char output_report_keys[3];
static unsigned char input_report_system_keys[3];
static unsigned char input_report_hw_keys[3];
static unsigned char input_report_media_keys[3];
static unsigned char input_report_ac_keys[3];
static unsigned char input_report_mouse[9];
static unsigned char feature_report_mouse[3];
static unsigned char input_report_mouse_abs[7];


/*
 * Clear and initialize the Keyboard Input Report.
 */
static void reset_input_report_keys()
{
	memset(input_report_keys, 0, sizeof(input_report_keys));

	input_report_keys[0] = BTTHT_DATA | BTTHP_DATA_INPUT;
	input_report_keys[1] = HIDC_REPORTID_KEYBOARD;
}

/*
 * Get the actual size of the Keyboard Input Report.
 *
 * Returns:
 *     The byte count of the Report.
 */
static size_t get_input_report_keys_size()
{
	return sizeof(input_report_keys);
}

/*
 * Clear and initialize the Keyboard Output Report.
 */
static void reset_output_report_keys()
{
	memset(output_report_keys, 0, sizeof(output_report_keys));

	output_report_keys[0] = BTTHT_DATA | BTTHP_DATA_OUTPUT;
	output_report_keys[1] = HIDC_REPORTID_KEYBOARD;
}

/*
 * Get the actual size of the Keyboard Output Report.
 *
 * Returns:
 *     The byte count of the Report.
 */
static size_t get_output_report_keys_size()
{
	return sizeof(output_report_keys);
}

/*
 * Clear and initialize the System Keys Input Report.
 */
static void reset_input_report_system_keys()
{
	memset(input_report_system_keys, 0, sizeof(input_report_system_keys));

	input_report_system_keys[0] = BTTHT_DATA | BTTHP_DATA_INPUT;
	input_report_system_keys[1] = HIDC_REPORTID_SYSTEM_KEYS;
}

/*
 * Get the actual size of the System Keys Input Report.
 *
 * Returns:
 *     The byte count of the Report.
 */
static size_t get_input_report_system_keys_size()
{
	return sizeof(input_report_system_keys);
}

/*
 * Clear and initialize the Hardware Keys Input Report.
 */
static void reset_input_report_hw_keys()
{
	memset(input_report_hw_keys, 0, sizeof(input_report_hw_keys));

	input_report_hw_keys[0] = BTTHT_DATA | BTTHP_DATA_INPUT;
	input_report_hw_keys[1] = HIDC_REPORTID_HW_KEYS;
}

/*
 * Get the actual size of the Hardware Keys Input Report.
 *
 * Returns:
 *     The byte count of the Report.
 */
static size_t get_input_report_hw_keys_size()
{
	return sizeof(input_report_hw_keys);
}

/*
 * Clear and initialize the Media Keys Input Report.
 */
static void reset_input_report_media_keys()
{
	memset(input_report_media_keys, 0, sizeof(input_report_media_keys));

	input_report_media_keys[0] = BTTHT_DATA | BTTHP_DATA_INPUT;
	input_report_media_keys[1] = HIDC_REPORTID_MEDIA_KEYS;
}

/*
 * Get the actual size of the Media Keys Input Report.
 *
 * Returns:
 *     The byte count of the Report.
 */
static size_t get_input_report_media_keys_size()
{
	return sizeof(input_report_media_keys);
}

/*
 * Clear and initialize the Application Control Keys Input Report.
 */
static void reset_input_report_ac_keys()
{
	memset(input_report_ac_keys, 0, sizeof(input_report_ac_keys));

	input_report_ac_keys[0] = BTTHT_DATA | BTTHP_DATA_INPUT;
	input_report_ac_keys[1] = HIDC_REPORTID_AC_KEYS;
}

/*
 * Get the actual size of the Application Control Keys Input Report.
 *
 * Returns:
 *     The byte count of the Report.
 */
static size_t get_input_report_ac_keys_size()
{
	return sizeof(input_report_ac_keys);
}

/*
 * Clear and initialize the Mouse Input Report.
 */
static void reset_input_report_mouse()
{
	memset(input_report_mouse, 0, sizeof(input_report_mouse));

	input_report_mouse[0] = BTTHT_DATA | BTTHP_DATA_INPUT;
	input_report_mouse[1] = HIDC_REPORTID_MOUSE;
}

/*
 * Get the actual size of the Mouse Input Report.
 *
 * Returns:
 *     The byte count of the Report.
 */
static size_t get_input_report_mouse_size()
{
	return (use_report_protocol ? sizeof(input_report_mouse) : 5);
}

/*
 * Clear and initialize the Mouse (Absolute) Input Report.
 */
static void reset_input_report_mouse_abs()
{
	memset(input_report_mouse_abs, 0, sizeof(input_report_mouse_abs));

	input_report_mouse_abs[0] = BTTHT_DATA | BTTHP_DATA_INPUT;
	input_report_mouse_abs[1] = HIDC_REPORTID_MOUSE_ABSOLUTE;
}

/*
 * Get the actual size of the Mouse (Absolute) Input Report.
 *
 * Returns:
 *     The byte count of the Report.
 */
static size_t get_input_report_mouse_abs_size()
{
	return sizeof(input_report_mouse_abs);
}

/*
 * Clear and initialize the Mouse Feature Report.
 */
static void reset_feature_report_mouse()
{
	memset(feature_report_mouse, 0, sizeof(feature_report_mouse));

	feature_report_mouse[0] = BTTHT_DATA | BTTHP_DATA_FEATURE;
	feature_report_mouse[1] = HIDC_REPORTID_MOUSE_FEATURE;
}

/*
 * Get the actual size of the Mouse Feature Report.
 *
 * Returns:
 *     The byte count of the Report.
 */
static size_t get_feature_report_mouse_size()
{
	return sizeof(feature_report_mouse);
}


/*
 * Limit the given integer value.
 *
 * Parameters:
 *     value: The value.
 *     min: The minimum allowed value.
 *     max: The maximum allowed value.
 *
 * Returns:
 *     The limited value.
 */
static int limit_int_value(int value, int min, int max)
{
	if (value > max)
		return max;
	else if (value < min)
		return min;
	else
		return value;
}

/*
 * Set HID Profile specific options for the L2CAP socket.
 *
 * Parameters:
 *     socket: The L2CAP socket.
 */
static void set_general_sockopt(int socket)
{
	struct l2cap_options opts;

	memset(&opts, 0, sizeof(opts));
	opts.imtu = INPUT_MTU;
	opts.omtu = OUTPUT_MTU;
	opts.flush_to = FLUSH_TIMEOUT;

	setsockopt(socket, SOL_L2CAP, L2CAP_OPTIONS, &opts, sizeof(opts));

	/*
	 * TODO: Configure QoS parameters for the L2CAP connections
	 * See chapter 7.8 in the "Bluetooth HID Profile" documentation.
	 */
}

/*
 * Listen on a L2CAP PSM.
 * This function is based on the "l2cap_listen" function from the BlueZ code.
 *
 * Parameters:
 *     bdaddr: The Bluetooth address of the client adapter.
 *     psm: The Protocol Service Multiplexor.
 *     lm: Link mode options.
 *     backlog: Allowed pending connection number.
 *
 * Returns:
 *     The listening socket descriptor on success or -1 on failure.
 */
static int l2cap_listen(const bdaddr_t *bdaddr,
			unsigned short psm,
			int lm,
			int backlog)
{
	struct sockaddr_l2 addr;  /* socket address */
	int sk;  /* socket descriptor */

	if ((sk = socket(PF_BLUETOOTH, SOCK_SEQPACKET, BTPROTO_L2CAP)) < 0)
		return -1;

	memset(&addr, 0, sizeof(addr));
	addr.l2_family = AF_BLUETOOTH;
	bacpy(&addr.l2_bdaddr, bdaddr);
	addr.l2_psm = htobs(psm);

	if (bind(sk, (struct sockaddr *) &addr, sizeof(addr)) < 0) {
		close(sk);
		return -1;
	}

	setsockopt(sk, SOL_L2CAP, L2CAP_LM, &lm, sizeof(lm));

	set_general_sockopt(sk);

	if (listen(sk, backlog) < 0) {
		close(sk);
		return -1;
	}

	return sk;
}

/*
 * Accept a L2CAP connection.
 * This function is based on the "l2cap_accept" function from the BlueZ code.
 *
 * Parameters:
 *     sk: The listening socket descriptor.
 *     bdaddr: Changed to the Bluetooth address of the accepted connection.
 *
 * Returns:
 *     The client socket descriptor on success or -1 on failure.
 */
static int l2cap_accept(int sk, bdaddr_t *bdaddr)
{
	struct sockaddr_l2 addr;  /* socket address */
	socklen_t addrlen;  /* socket address length */
	int csk;  /* client socket descriptor */

	memset(&addr, 0, sizeof(addr));
	addrlen = sizeof(addr);

	if ((csk = accept(sk, (struct sockaddr *) &addr, &addrlen)) < 0)
		return -1;

	if (bdaddr)
		bacpy(bdaddr, &addr.l2_bdaddr);

	return csk;
}

/*
 * Open a L2CAP connection.
 * This function is based on the "l2cap_connect" function from the BlueZ code.
 *
 * Parameters:
 *     src: The Bluetooth address of the client adapter.
 *     dst: The destination Bluetooth address.
 *     psm: The Protocol Service Multiplexor.
 *
 * Returns:
 *     The connected socket descriptor on success or -1 on failure.
 */
static int l2cap_connect(bdaddr_t *src, bdaddr_t *dst, unsigned short psm)
{
	struct sockaddr_l2 addr;  /* socket address */
	int sk;  /* socket descriptor */

	if ((sk = socket(PF_BLUETOOTH, SOCK_SEQPACKET, BTPROTO_L2CAP)) < 0)
		return -1;

	memset(&addr, 0, sizeof(addr));
	addr.l2_family  = AF_BLUETOOTH;
	bacpy(&addr.l2_bdaddr, src);

	if (bind(sk, (struct sockaddr *) &addr, sizeof(addr)) < 0) {
		close(sk);
		return -1;
	}

	set_general_sockopt(sk);

	memset(&addr, 0, sizeof(addr));
	addr.l2_family  = AF_BLUETOOTH;
	bacpy(&addr.l2_bdaddr, dst);
	addr.l2_psm = htobs(psm);

	if (connect(sk, (struct sockaddr *) &addr, sizeof(addr)) < 0) {
		close(sk);
		return -1;
	}

	return sk;
}

/*
 * Called after a HID host got connected.
 *
 * Parameters:
 *     dst_addr: The Bluetooth address of the host.
 */
static void on_hid_connected(bdaddr_t *dst_addr)
{
	char str_addr[18];

	bacpy(&last_bdaddr, dst_addr);

	use_report_protocol = 1;

	reset_input_report_keys();
	reset_output_report_keys();
	reset_input_report_system_keys();
	reset_input_report_hw_keys();
	reset_input_report_media_keys();
	reset_input_report_ac_keys();
	reset_input_report_mouse();
	reset_input_report_mouse_abs();
	reset_feature_report_mouse();

	ba2str(dst_addr, str_addr);
	log_i("HID connected (%s)", str_addr);

	hidc_send_ipc_cb_connected(dst_addr);
}

/*
 * Disconnect a active HID connection.
 *
 * Parameters:
 *     ec: An error code if the function was called because of an error or 0 if
 *         it is an ordinary disconnect.
 */
static void close_client_sockets(int ec)
{
	int con_closed = 0;

	if (client_intr_sock > -1) {
		if (close(client_intr_sock) < 0)
			log_ec(errno, "Can't close HID interrupt socket");

		client_intr_sock = -1;
		con_closed = 1;
	}

	if (client_ctrl_sock > -1) {
		if (close(client_ctrl_sock) < 0)
			log_ec(errno, "Can't close HID control socket");

		client_ctrl_sock = -1;
		con_closed = 1;
	}

	if (con_closed) {
		log_i("HID connection closed");
		hidc_send_ipc_cb_disconnected(ec);
	}
}

/*
 * Send a Bluetooth HID data Report.
 *
 * Parameters:
 *     socket: The sending socket.
 *     data: The complete (with Transaction Header) Report data.
 *     data_size: The size of the data parameter.
 */
static void send_data_report(int socket, unsigned char *data, int data_size)
{
	int errsv;  /* saved errno */

	if (socket < 0)
		return;

	if (send(socket, data, data_size, 0) <= 0) {
		errsv = errno;
		log_ec(errsv, "Can't write to HID socket");
		close_client_sockets(hidc_convert_errno(errsv));
	}
}

/*
 * Send a Bluetooth HID handshake command.
 *
 * Parameters:
 *     socket: The sending socket.
 *     param: The handshake Bluetooth HID Transaction Header parameter.
 */
static void send_handshake(int socket, unsigned char param)
{
	unsigned char report_data[1];

	report_data[0] = BTTHT_HANDSHAKE | param;

	send_data_report(socket, report_data, sizeof(report_data));
}

/*
 * Log binary data with a description.
 *
 * Parameters:
 *     desc: A description message for the data.
 *     data: The binary data.
 *     data_size: The size of the data parameter.
 */
static void log_data_bytes(const char *desc, unsigned char *data,
				int data_size)
{
	int i;
	int is_truncated = 0;
	size_t datastr_size;
	char *datastr;

	if (!log_is_debug_active() || (data_size < 1))
		return;

	if (data_size > 20) {
		data_size = 20;
		is_truncated = 1;
	}

	datastr_size = (data_size * 3) + 1;
	datastr = malloc(datastr_size);
	if (!datastr) {
		log_e("Can't log %s: malloc error", desc);
		return;
	}

	sprintf(datastr, "%02x", data[0]);
	for (i = 1; i < data_size; i++)
		sprintf(datastr + ((i * 3) - 1), " %02x", data[i]);

	if (is_truncated)
		log_d("%s (%s...)", desc, datastr);
	else
		log_d("%s (%s)", desc, datastr);

	free(datastr);
}

/*
 * Called when a Output Report is received.
 *
 * Parameters:
 *     data: The complete (with Transaction Header) Report data.
 *     data_size: The size of the data parameter.
 */
static void on_receive_output_report(unsigned char *data, int data_size)
{
	unsigned char reportid = 0;

	if (data_size > 1)
		reportid = data[1];

	switch (reportid) {
	case HIDC_REPORTID_KEYBOARD:
		if (data_size < get_output_report_keys_size()) {
			log_e("Invalid Keyboard Output Report");
			return;
		}
		memcpy(output_report_keys + 2,
			data + 2,
			get_output_report_keys_size() - 2);
		/* LED output Report isn't supported and ignored */
		log_data_bytes("Ignored Keyboard Output Report",
				data,
				data_size);
		break;
	default:
		log_data_bytes("Unknown Output Report", data, data_size);
		break;
	}
}

/*
 * Called when a Feature Report is received.
 *
 * Parameters:
 *     data: The complete (with Transaction Header) Report data.
 *     data_size: The size of the data parameter.
 */
static void on_receive_feature_report(unsigned char *data, int data_size)
{
	unsigned char reportid = 0;
	int smooth_scroll_y;
	int smooth_scroll_x;

	if (data_size > 1)
		reportid = data[1];

	switch (reportid) {
	case HIDC_REPORTID_MOUSE_FEATURE:
		if (data_size < get_feature_report_mouse_size()) {
			log_e("Invalid Mouse Feature Report");
			return;
		}
		memcpy(feature_report_mouse + 2,
			data + 2,
			get_feature_report_mouse_size() - 2);

		smooth_scroll_y = (feature_report_mouse[2] & 0x01) != 0;
		smooth_scroll_x = (feature_report_mouse[2] & 0x04) != 0;
		hidc_send_ipc_cb_mouse_feature(smooth_scroll_y,
						smooth_scroll_x);

		log_data_bytes("Mouse Feature Report received",
				data,
				data_size);
		break;
	default:
		log_data_bytes("Unknown Feature Report", data, data_size);
		break;
	}
}

/*
 * Bluetooth documentation quote:
 * This code requests a major state change in a BT-HID device. A HID_CONTROL
 * request does not generate a HANDSHAKE response.
 *
 * Parameters:
 *     param: Bluetooth HID Transaction Header Parameter.
 *     data: Complete received data.
 *     data_size: Size of the data parameter.
 */
static void on_cmd_hid_control(unsigned char param, unsigned char *data,
				int data_size)
{
	switch (param) {
	case BTTHP_HID_CTRL_NOP:
		/* do nothing */
		break;
	case BTTHP_HID_CTRL_HARD_RESET:
		log_d("Host sent Hard Reset command");
		close_client_sockets(0);
		break;
	case BTTHP_HID_CTRL_SOFT_RESET:
		log_d("Host sent Soft Reset command");
		close_client_sockets(0);
		break;
	case BTTHP_HID_CTRL_SUSPEND:
		log_d("Host sent Suspend command");
		/*
		 * Instead of entering a Bluetooth energy mode, simply
		 * disconnect the HID because we can reconnect on user input.
		 */
		close_client_sockets(0);
		break;
	case BTTHP_HID_CTRL_EXIT_SUSPEND:
		log_d("Host sent Exit Suspend command");
		break;
	case BTTHP_HID_CTRL_VC_UNPLUG:
		log_d("Host sent Virtual Cable Unplug");
		close_client_sockets(0);
		break;
	default:
		log_d("Unknown HID Control parameter (%02x)", param);
		break;
	}
}

/*
 * Bluetooth documentation quote:
 * This code indicates that the host wants to retrieve a report from the
 * BT-HID device. Upon receipt of this request, the device will return a DATA
 * payload on the Control channel containing the requested report.
 *
 * Parameters:
 *     param: Bluetooth HID Transaction Header Parameter.
 *     data: Complete received data.
 *     data_size: Size of the data parameter.
 */
static void on_cmd_get_report(unsigned char param, unsigned char *data,
				int data_size)
{
	unsigned char reportid = 0;
	uint16_t buffer_size = 0;
	unsigned char *report_data = NULL;
	int report_size = 0;

	if (data_size > 1)
		reportid = data[1];

	switch (param) {
	case BTTHP_GET_REPORT_INPUT_BUFF:
	case BTTHP_GET_REPORT_OUTPUT_BUFF:
	case BTTHP_GET_REPORT_FEATURE_BUFF:
		if (data_size > 3) {
			buffer_size = ntohs((uint16_t)data[2]);
			/* Add DATA Header byte */
			buffer_size = buffer_size + 1;
		}
		break;
	}

	switch (param) {
	case BTTHP_GET_REPORT_INPUT:
	case BTTHP_GET_REPORT_INPUT_BUFF:
		if (reportid == HIDC_REPORTID_KEYBOARD) {
			report_data = input_report_keys;
			report_size = get_input_report_keys_size();
		}
		else if (reportid == HIDC_REPORTID_SYSTEM_KEYS) {
			report_data = input_report_system_keys;
			report_size = get_input_report_system_keys_size();
		}
		else if (reportid == HIDC_REPORTID_HW_KEYS) {
			report_data = input_report_hw_keys;
			report_size = get_input_report_hw_keys_size();
		}
		else if (reportid == HIDC_REPORTID_MEDIA_KEYS) {
			report_data = input_report_media_keys;
			report_size = get_input_report_media_keys_size();
		}
		else if (reportid == HIDC_REPORTID_AC_KEYS) {
			report_data = input_report_ac_keys;
			report_size = get_input_report_ac_keys_size();
		}
		else if (reportid == HIDC_REPORTID_MOUSE) {
			report_data = input_report_mouse;
			report_size = get_input_report_mouse_size();
		}
		else if (reportid == HIDC_REPORTID_MOUSE_ABSOLUTE) {
			report_data = input_report_mouse_abs;
			report_size = get_input_report_mouse_abs_size();
		}
		break;
	case BTTHP_GET_REPORT_OUTPUT:
	case BTTHP_GET_REPORT_OUTPUT_BUFF:
		if (reportid == HIDC_REPORTID_KEYBOARD) {
			report_data = output_report_keys;
			report_size = get_output_report_keys_size();
		}
		break;
	case BTTHP_GET_REPORT_FEATURE:
	case BTTHP_GET_REPORT_FEATURE_BUFF:
		if (reportid == HIDC_REPORTID_MOUSE_FEATURE) {
			report_data = feature_report_mouse;
			report_size = get_feature_report_mouse_size();
		}
		break;
	}

	if (buffer_size == 0 || buffer_size > report_size)
		buffer_size = report_size;

	if (report_data != NULL && buffer_size > 0) {
		log_data_bytes("Respond to Get Report", data, data_size);
		send_data_report(client_ctrl_sock, report_data, buffer_size);
	}
	else {
		log_data_bytes("Unknown Get Report", data, data_size);
		send_handshake(client_ctrl_sock,
				BTTHP_HANDSHAKE_ERR_INV_PARAM);
	}
}

/*
 * Bluetooth documentation quote:
 * This Transaction Type indicates that the host is sending a report to a
 * BT-HID device. The 1-byte SET_REPORT Transaction Header is immediately
 * followed by a single report.
 *
 * Parameters:
 *     param: Bluetooth HID Transaction Header Parameter.
 *     data: Complete received data.
 *     data_size: Size of the data parameter.
 */
static void on_cmd_set_report(unsigned char param, unsigned char *data,
				int data_size)
{
	switch (param) {
	case BTTHP_SET_REPORT_OUTPUT:
		on_receive_output_report(data, data_size);
		break;
	case BTTHP_SET_REPORT_FEATURE:
		on_receive_feature_report(data, data_size);
		break;
	default:
		log_data_bytes("Unknown Set Report", data, data_size);
		send_handshake(client_ctrl_sock,
				BTTHP_HANDSHAKE_ERR_INV_PARAM);
		return;
	}

	send_handshake(client_ctrl_sock, BTTHP_HANDSHAKE_SUCCESS);
}

/*
 * Bluetooth documentation quote:
 * This code is used to retrieve the current protocol on the BT-HID device.
 * The device responds with a single byte DATA payload that indicates the
 * current protocol.
 *
 * Parameters:
 *     param: Bluetooth HID Transaction Header Parameter.
 *     data: Complete received data.
 *     data_size: Size of the data parameter.
 */
static void on_cmd_get_protocol(unsigned char param, unsigned char *data,
				int data_size)
{
	unsigned char report_data[2];

	report_data[0] = BTTHT_DATA | BTTHP_DATA_OTHER;
	report_data[1] = use_report_protocol ? 0x01 : 0x00;

	log_d("Respond to Get Protocol");
	send_data_report(client_ctrl_sock, report_data, sizeof(report_data));
}

/*
 * Bluetooth documentation quote:
 * This code is used to set a specific protocol on the BT-HID device. Special
 * Boot protocols are defined for keyboards and mice.
 *
 * Parameters:
 *     param: Bluetooth HID Transaction Header Parameter.
 *     data: Complete received data.
 *     data_size: Size of the data parameter.
 */
static void on_cmd_set_protocol(unsigned char param, unsigned char *data,
				int data_size)
{
	switch (param) {
	case BTTHP_SET_PROTOCOL_BOOT:
		log_d("Set Protocol (Boot) received");
		use_report_protocol = 0;
		break;
	case BTTHP_SET_PROTOCOL_REPORT:
		log_d("Set Protocol (Report) received");
		use_report_protocol = 1;
		break;
	default:
		log_data_bytes("Unknown Set Protocol parameter",
				data,
				data_size);
		send_handshake(client_ctrl_sock,
				BTTHP_HANDSHAKE_ERR_INV_PARAM);
		return;
	}

	send_handshake(client_ctrl_sock, BTTHP_HANDSHAKE_SUCCESS);
}

/*
 * Bluetooth documentation quote:
 * This code is used to retrieve the current Idle setting of the BT-HID
 * device. The device responds with a single byte DATA payload that indicates
 * the current Idle setting.
 *
 * Parameters:
 *     param: Bluetooth HID Transaction Header Parameter.
 *     data: Complete received data.
 *     data_size: Size of the data parameter.
 */
static void on_cmd_get_idle(unsigned char param, unsigned char *data,
				int data_size)
{
	unsigned char report_data[2];

	report_data[0] = BTTHT_DATA | BTTHP_DATA_OTHER;
	report_data[1] = 0x00;

	log_d("Respond to Get Idle");
	send_data_report(client_ctrl_sock, report_data, sizeof(report_data));
}

/*
 * Bluetooth documentation quote:
 * This code is used to set a specific Idle rate of a BT-HID device. Set Idle
 * is optional for hosts and required for keyboards.
 *
 * Parameters:
 *     param: Bluetooth HID Transaction Header Parameter.
 *     data: Complete received data.
 *     data_size: Size of the data parameter.
 */
static void on_cmd_set_idle(unsigned char param, unsigned char *data,
				int data_size)
{
	/*
	 * Changing the Idle interval isn't supported, because it is difficult
	 * to implement and only a compatibility feature which is not
	 * recommended regarding to the Bluetooth documentation. But it is
	 * required to support this command, so just send a success message.
	 */
	log_data_bytes("Ignored Set Idle", data, data_size);
	send_handshake(client_ctrl_sock, BTTHP_HANDSHAKE_SUCCESS);
}

/*
 * Bluetooth documentation quote:
 * This Transaction Type identifies a HID payload. ... All DATA payloads on
 * the Interrupt channel that flow from the host to the device are Output
 * Reports.
 *
 * Parameters:
 *     param: Bluetooth HID Transaction Header Parameter.
 *     data: Complete received data.
 *     data_size: Size of the data parameter.
 */
static void on_cmd_data(unsigned char param, unsigned char *data,
				int data_size)
{
	switch (param) {
	case BTTHP_DATA_OUTPUT:
		on_receive_output_report(data, data_size);
		break;
	default:
		log_data_bytes("Unknown Data Report", data, data_size);
		send_handshake(client_ctrl_sock,
				BTTHP_HANDSHAKE_ERR_INV_PARAM);
		break;
	}
}

/*
 * Bluetooth documentation quote:
 * Data Continuation: This code identifies the continuation of a HID payload
 * that equaled or exceeded the negotiated MTU.
 *
 * Parameters:
 *     param: Bluetooth HID Transaction Header Parameter.
 *     data: Complete received data.
 *     data_size: Size of the data parameter.
 */
static void on_cmd_datac(unsigned char param, unsigned char *data,
				int data_size)
{
	/*
	 * Not necessary if the MTU is at least one byte larger than the
	 * largest Report.
	 */
	log_data_bytes("Ignored Data Continuation", data, data_size);
}

/*
 * Handle a poll input event on the server control socket.
 */
static void pollin_server_ctrl_sock()
{
	int socket;
	bdaddr_t dst_addr;  /* destination address */
	char str_addr[18];  /* address as a String */

	socket = l2cap_accept(server_ctrl_sock, &dst_addr);
	if (socket < 0) {
		log_ec(errno, "Can't accept HID control socket");
		return;
	}

	if (hidc_is_hid_connected()) {
		ba2str(&dst_addr, str_addr);
		log_i("Host connection request blocked (%s): "
			"already connected", str_addr);
		close(socket);
	}
	else {
		client_ctrl_sock = socket;
		if (hidc_is_hid_connected())
			on_hid_connected(&dst_addr);
	}
}

/*
 * Handle a poll input event on the server interrupt socket.
 */
static void pollin_server_intr_sock()
{
	int socket;
	bdaddr_t dst_addr;  /* destination address */

	socket = l2cap_accept(server_intr_sock, &dst_addr);
	if (socket < 0) {
		log_ec(errno, "Can't accept HID interrupt socket");
		return;
	}

	if (hidc_is_hid_connected()) {
		close(socket);
	}
	else {
		client_intr_sock = socket;
		if (hidc_is_hid_connected())
			on_hid_connected(&dst_addr);
	}
}

/*
 * Handle a poll input event on the client control socket.
 */
static void pollin_client_ctrl_sock()
{
	int errsv;  /* saved errno */
	unsigned char thdr_type;  /* Bluetooth HID Transaction Header Type */
	unsigned char thdr_param;  /* Bluetooth HID Transaction Header Param */
	int rsize;  /* received size */
	unsigned char rbuffer[INPUT_MTU];  /* receive buffer */

	rsize = recv(client_ctrl_sock, rbuffer, sizeof(rbuffer), 0);
	if (rsize < 0) {
		errsv = errno;
		log_ec(errsv, "Can't read on HID control socket");
		close_client_sockets(hidc_convert_errno(errsv));
		return;
	}
	else if (rsize == 0) {
		log_d("Remote closed HID control connection");
		close_client_sockets(0);
		return;
	}

	thdr_type = rbuffer[0] & 0xf0;
	thdr_param = rbuffer[0] & 0x0f;

	switch (thdr_type) {
	case BTTHT_HID_CTRL:
		on_cmd_hid_control(thdr_param, rbuffer, rsize);
		break;
	case BTTHT_GET_REPORT:
		on_cmd_get_report(thdr_param, rbuffer, rsize);
		break;
	case BTTHT_SET_REPORT:
		on_cmd_set_report(thdr_param, rbuffer, rsize);
		break;
	case BTTHT_GET_PROTOCOL:
		on_cmd_get_protocol(thdr_param, rbuffer, rsize);
		break;
	case BTTHT_SET_PROTOCOL:
		on_cmd_set_protocol(thdr_param, rbuffer, rsize);
		break;
	case BTTHT_GET_IDLE:
		on_cmd_get_idle(thdr_param, rbuffer, rsize);
		break;
	case BTTHT_SET_IDLE:
		on_cmd_set_idle(thdr_param, rbuffer, rsize);
		break;
	default:
		log_data_bytes("Unknown control data", rbuffer, rsize);
		send_handshake(client_ctrl_sock,
				BTTHP_HANDSHAKE_ERR_UNSUPPORTED);
		break;
	}
}

/*
 * Handle a poll input event on the client interrupt socket.
 */
static void pollin_client_intr_sock()
{
	int errsv;  /* saved errno */
	unsigned char thdr_type;  /* Bluetooth HID Transaction Header Type */
	unsigned char thdr_param;  /* Bluetooth HID Transaction Header Param */
	int rsize;  /* received size */
	unsigned char rbuffer[INPUT_MTU];  /* receive buffer */

	rsize = recv(client_intr_sock, rbuffer, sizeof(rbuffer), 0);
	if (rsize < 0) {
		errsv = errno;
		log_ec(errsv, "Can't read on HID interrupt socket");
		close_client_sockets(hidc_convert_errno(errsv));
		return;
	}
	else if (rsize == 0) {
		log_d("Remote closed HID interrupt connection");
		close_client_sockets(0);
		return;
	}

	thdr_type = rbuffer[0] & 0xf0;
	thdr_param = rbuffer[0] & 0x0f;

	switch (thdr_type) {
	case BTTHT_DATA:
		on_cmd_data(thdr_param, rbuffer, rsize);
		break;
	case BTTHT_DATAC:
		on_cmd_datac(thdr_param, rbuffer, rsize);
		break;
	default:
		log_data_bytes("Unknown interrupt data", rbuffer, rsize);
		send_handshake(client_ctrl_sock,
				BTTHP_HANDSHAKE_ERR_UNSUPPORTED);
		break;
	}
}


int hidc_start_hid_server()
{
	int errsv;  /* saved errno */

	if (server_ctrl_sock < 0) {
		server_ctrl_sock = l2cap_listen(hidc_get_app_dev_bdaddr(),
						L2CAP_PSM_HIDP_CTRL,
						0,
						1);
		if (server_ctrl_sock < 0) {
			errsv = errno;
			if (errsv == EADDRINUSE) {
				log_i("The HID server address is already in "
					"use");
			}
			else {
				log_ec(errsv,
					"Can't create HID control socket");
			}
			return hidc_convert_errno(errsv);
		}
	}

	if (server_intr_sock < 0) {
		server_intr_sock = l2cap_listen(hidc_get_app_dev_bdaddr(),
						L2CAP_PSM_HIDP_INTR,
						0,
						1);
		if (server_intr_sock < 0) {
			errsv = errno;
			log_ec(errsv, "Can't create HID interrupt socket");
			close(server_ctrl_sock);
			server_ctrl_sock = -1;
			return hidc_convert_errno(errsv);
		}
	}

	log_d("HID server started");

	return 0;
}

void hidc_stop_hid_server()
{
	int stopped = 0;

	if (server_intr_sock > -1) {
		close(server_intr_sock);
		server_intr_sock = -1;
		stopped = 1;
	}

	if (server_ctrl_sock > -1) {
		close(server_ctrl_sock);
		server_ctrl_sock = -1;
		stopped = 1;
	}

	if (stopped)
		log_d("HID server stopped");
}

int hidc_is_hid_server_running()
{
	return (server_ctrl_sock > -1 && server_intr_sock > -1);
}

int hidc_connect_hid(bdaddr_t *dst_addr)
{
	int errsv;  /* saved errno */

	if (hidc_is_hid_connected())
		return 0;

	client_ctrl_sock = l2cap_connect(hidc_get_app_dev_bdaddr(),
					dst_addr,
					L2CAP_PSM_HIDP_CTRL);
	if (client_ctrl_sock < 0) {
		errsv = errno;
		log_ec(errsv, "Can't connect HID control socket");
		return hidc_convert_errno(errsv);
	}

	client_intr_sock = l2cap_connect(hidc_get_app_dev_bdaddr(),
					dst_addr,
					L2CAP_PSM_HIDP_INTR);
	if (client_intr_sock < 0) {
		errsv = errno;
		log_ec(errsv, "Can't connect HID interrupt socket");
		close(client_ctrl_sock);
		client_ctrl_sock = -1;
		return hidc_convert_errno(errsv);
	}

	on_hid_connected(dst_addr);

	return 0;
}

void hidc_disconnect_hid()
{
	close_client_sockets(0);
}

int hidc_is_hid_connected()
{
	return (client_ctrl_sock > -1 && client_intr_sock > -1);
}

void get_last_connected_bdaddr(bdaddr_t *bdaddr)
{
	bacpy(bdaddr, &last_bdaddr);
}

void hidc_send_hid_report_keys(unsigned char modifiers,
	const unsigned char *keycodes)
{
	reset_input_report_keys();

	input_report_keys[2] = modifiers;
	input_report_keys[3] = 0x00;  /* Reserved */
	memcpy(input_report_keys + 4, keycodes, 6);

	send_data_report(client_intr_sock,
			input_report_keys,
			get_input_report_keys_size());
}

void hidc_send_hid_report_system_keys(unsigned char keys)
{
	reset_input_report_system_keys();

	input_report_system_keys[2] = keys;

	send_data_report(client_intr_sock,
			input_report_system_keys,
			get_input_report_system_keys_size());
}

void hidc_send_hid_report_hw_keys(unsigned char keys)
{
	reset_input_report_hw_keys();

	input_report_hw_keys[2] = keys;

	send_data_report(client_intr_sock,
			input_report_hw_keys,
			get_input_report_hw_keys_size());
}

void hidc_send_hid_report_media_keys(unsigned char keys)
{
	reset_input_report_media_keys();

	input_report_media_keys[2] = keys;

	send_data_report(client_intr_sock,
			input_report_media_keys,
			get_input_report_media_keys_size());
}

void hidc_send_hid_report_ac_keys(unsigned char keys)
{
	reset_input_report_ac_keys();

	input_report_ac_keys[2] = keys;

	send_data_report(client_intr_sock,
			input_report_ac_keys,
			get_input_report_ac_keys_size());
}

void hidc_send_hid_report_mouse(unsigned char buttons, int16_t x, int16_t y,
				signed char scrollY, signed char scrollX)
{
	reset_input_report_mouse();

	if (use_report_protocol) {
		x = htobs((int16_t)limit_int_value(x, -2047, 2047));
		y = htobs((int16_t)limit_int_value(y, -2047, 2047));

		scrollY = (signed char)limit_int_value(scrollY, -127, 127);
		scrollX = (signed char)limit_int_value(scrollX, -127, 127);

		input_report_mouse[2] = buttons;
		memcpy(input_report_mouse + 3, &x, 2);
		memcpy(input_report_mouse + 5, &y, 2);
		input_report_mouse[7] = scrollY;
		input_report_mouse[8] = scrollX;
	}
	else {
		/*
		 * The boot Mouse pointer will be moved roughly every quarter.
		 * Always round the value up, so the pointer is moving
		 * consistent even if the value is smaller than 4.
		 */
		x = (x + 3) / 4;
		y = (y + 3) / 4;

		x = (int16_t)limit_int_value(x, -127, 127);
		y = (int16_t)limit_int_value(y, -127, 127);

		input_report_mouse[2] = buttons;
		input_report_mouse[3] = (signed char)x;
		input_report_mouse[4] = (signed char)y;
	}

	send_data_report(client_intr_sock,
			input_report_mouse,
			get_input_report_mouse_size());
}

void hidc_send_hid_report_mouse_abs(unsigned char buttons, uint16_t x,
				uint16_t y)
{
	reset_input_report_mouse_abs();

	x = htobs((uint16_t)limit_int_value(x, 0, 2047));
	y = htobs((uint16_t)limit_int_value(y, 0, 2047));

	input_report_mouse_abs[2] = buttons;
	memcpy(input_report_mouse_abs + 3, &x, 2);
	memcpy(input_report_mouse_abs + 5, &y, 2);

	send_data_report(client_intr_sock,
			input_report_mouse_abs,
			get_input_report_mouse_abs_size());
}

void hidc_change_mouse_feature(int smooth_scroll_y, int smooth_scroll_x)
{
	unsigned char smooth_scroll_value = 0;

	if (smooth_scroll_y)
		smooth_scroll_value |= 0x01;

	if (smooth_scroll_x)
		smooth_scroll_value |= 0x04;

	feature_report_mouse[2] = smooth_scroll_value;

	/*
	 * TODO: Send a Feature Notification Report to the host
	 * See chapter 4.8 in the "USB HID Usage Tables" documentation.
	 */
}

void hidc_init_l2cap_pollfds(struct pollfd *scpollfd, struct pollfd *sipollfd,
			struct pollfd *ccpollfd, struct pollfd *cipollfd)
{
	scpollfd->fd = server_ctrl_sock;
	scpollfd->events = POLLIN;
	scpollfd->revents = 0;

	sipollfd->fd = server_intr_sock;
	sipollfd->events = POLLIN;
	sipollfd->revents = 0;

	ccpollfd->fd = client_ctrl_sock;
	ccpollfd->events = POLLIN | POLLERR | POLLHUP;
	ccpollfd->revents = 0;

	cipollfd->fd = client_intr_sock;
	cipollfd->events = POLLIN | POLLERR | POLLHUP;
	cipollfd->revents = 0;
}

void hidc_handle_l2cap_poll(struct pollfd *scpollfd, struct pollfd *sipollfd,
			struct pollfd *ccpollfd, struct pollfd *cipollfd)
{
	if (scpollfd->revents & POLLIN)
		pollin_server_ctrl_sock();

	if (sipollfd->revents & POLLIN)
		pollin_server_intr_sock();

	if (hidc_is_hid_connected()) {
		if (ccpollfd->revents & POLLIN) {
			pollin_client_ctrl_sock();
		}
		if (ccpollfd->revents & POLLERR) {
			log_e("Error on HID control socket");
			close_client_sockets(HIDC_EC_UNKNOWN);
		}
		if (ccpollfd->revents & POLLHUP) {
			log_d("Remote closed HID control connection");
			close_client_sockets(0);
		}

		if (cipollfd->revents & POLLIN) {
			pollin_client_intr_sock();
		}
		if (cipollfd->revents & POLLERR) {
			log_e("Error on HID interrupt socket");
			close_client_sockets(HIDC_EC_UNKNOWN);
		}
		if (cipollfd->revents & POLLHUP) {
			log_d("Remote closed HID interrupt connection");
			close_client_sockets(0);
		}
	}
}
